using PointAngleCS.Point;
using System.Collections.Generic;
using System.Linq;
using System;

namespace PointAngleCS.Processor
{
    public sealed class DefaultProcessor : IProcessor
    {
        public static int REPEAT_TIMES { get; } = 5;
        public static double PATTERN_STAY { get; } = 800;
        public static double PATTERN_DURATION { get; } = 200.0 / 150 * 1000;

        public static int POINT_SKIP { get; } = 3;

        public ProcessResult Process(IReadOnlyList<Coord> coords)
        {
            List<Coord>[] dividedStageCoords = new List<Coord>[REPEAT_TIMES];
            double timeOffset = 0;
            double stageDuration = PATTERN_STAY * 2 + PATTERN_DURATION;
            for (int i = 0, j = 0; i < REPEAT_TIMES; i++)
            {
                List<Coord> stageCoord = new List<Coord>();
                while (j < coords.Count)
                {
                    double time = coords[j].TimeOffset - timeOffset;
                    if (time <= stageDuration)
                    {
                        stageCoord.Add(coords[j]);
                        j++;
                    }
                    else
                    {
                        break;
                    }
                }
                timeOffset += stageDuration;
                dividedStageCoords[i] = stageCoord;
            }

            int[] numberPredictions = new int[REPEAT_TIMES];
            for (int i = 0; i < REPEAT_TIMES; i++)
            {
                List<Coord> stageCoord = dividedStageCoords[i];
                stageCoord = stageCoord.Skip(POINT_SKIP).Reverse().Skip(POINT_SKIP).Reverse().ToList();
                int count = stageCoord.Count;
                if (count <= 1)
                {
                    numberPredictions[i] = 0;
                    continue;
                }

                double xSum = 0;
                double ySum = 0;
                foreach (Coord coord in stageCoord)
                {
                    xSum += coord.X;
                    ySum += coord.Y;
                }

                double xAvg = xSum / count;
                double yAvg = ySum / count;
                double molecular = 0;
                double denominator = 0;
                foreach (Coord coord in stageCoord)
                {
                    molecular += (coord.X - xAvg) * (coord.Y - yAvg);
                    denominator += System.Math.Pow(coord.X - xAvg, 2);
                }
                double scale = molecular / denominator;

                double dxSum = 0;
                double dySum = 0;
                int gap = count / 2;
                for (int j = 0, k = gap; k < count; j++, k++)
                {
                    dxSum += stageCoord[k].X - stageCoord[j].X;
                    dySum += stageCoord[k].Y - stageCoord[j].Y;
                }


                if (scale >= -1 && scale <= 1)
                {
                    numberPredictions[i] = dxSum < 0 ? 1 : 3;
                }
                else
                {
                    numberPredictions[i] = dySum < 0 ? 4 : 2;
                }
            }
            return new ProcessResult(coords, numberPredictions);
        }

    }
}
