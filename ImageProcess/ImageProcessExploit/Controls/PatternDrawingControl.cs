using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Media;
using System.Windows.Threading;

namespace ImageProcess.Controls
{
    public class PatternDrawingControl : UIElement
    {
        private int stage = 0;
        private SolidColorBrush block1Color = new SolidColorBrush(Colors.Red);
        private SolidColorBrush block2Color = new SolidColorBrush(Colors.Yellow);
        private SolidColorBrush block3Color = new SolidColorBrush(Colors.Blue);
        private SolidColorBrush block4Color = new SolidColorBrush(Colors.Green);
        private DateTime startTime;
        private double halfBlockSize = 15;
        private double blockSize = 31;

        private double speed;
        private double patternStay = 800;
        private int repeat = 4;
        private int currentRepeat = 0;
        private int moveDistance = 200;
        private double roundDuration;

        public event EventHandler MoveBegin;
        public event EventHandler MoveEnded;

        private DispatcherTimer timer;

        public PatternDrawingControl()
        {
        }

        public void SetPattern(double speed)
        {
            this.speed = speed;
            roundDuration = moveDistance / speed;
        }

        public void Start()
        {
            stage = 1;
            startTime = DateTime.Now;
            MoveBegin?.Invoke(this, null);
            timer = new DispatcherTimer(
                interval: TimeSpan.FromMilliseconds(10),
                priority: DispatcherPriority.Send,
                callback: (o, e) => InvalidateVisual(),
                dispatcher: Dispatcher);
            timer.Start();
        }

        protected override void OnRender(DrawingContext drawingContext)
        {
            double halfX = RenderSize.Width / 2;
            double halfY = RenderSize.Height / 2;

            switch (stage)
            {
                case 0:
                    drawingContext.DrawRectangle(block1Color, null, new Rect(halfX - halfBlockSize - blockSize, halfY - halfBlockSize, blockSize, blockSize));
                    drawingContext.DrawRectangle(block2Color, null, new Rect(halfX - halfBlockSize, halfY - halfBlockSize - blockSize, blockSize, blockSize));
                    drawingContext.DrawRectangle(block3Color, null, new Rect(halfX + halfBlockSize, halfY - halfBlockSize, blockSize, blockSize));
                    drawingContext.DrawRectangle(block4Color, null, new Rect(halfX - halfBlockSize, halfY + halfBlockSize, blockSize, blockSize));
                    break;
                case 1:
                    double currentDiff = (DateTime.Now - startTime).TotalMilliseconds;
                    double move = 0;
                    if (currentDiff > patternStay)
                    {
                        currentDiff -= patternStay;
                        if (currentDiff < roundDuration)
                        {
                            move = currentDiff / roundDuration * moveDistance;
                        }
                        else if (currentDiff > roundDuration + patternStay)
                        {
                            move = moveDistance;
                            startTime = DateTime.Now;
                            if (currentRepeat >= repeat)
                            {
                                stage = 2;
                                MoveEnded?.Invoke(this, null);
                            }
                            else
                            {
                                currentRepeat++;
                            }

                        }
                        else
                        {
                            move = moveDistance;
                        }
                    }
                    drawingContext.DrawRectangle(block1Color, null, new Rect(halfX - halfBlockSize - blockSize - move, halfY - halfBlockSize, blockSize, blockSize));
                    drawingContext.DrawRectangle(block2Color, null, new Rect(halfX - halfBlockSize, halfY - halfBlockSize - blockSize - move, blockSize, blockSize));
                    drawingContext.DrawRectangle(block3Color, null, new Rect(halfX + halfBlockSize + move, halfY - halfBlockSize, blockSize, blockSize));
                    drawingContext.DrawRectangle(block4Color, null, new Rect(halfX - halfBlockSize, halfY + halfBlockSize + move, blockSize, blockSize));
                    break;
                case 2:
                default:
                    drawingContext.DrawRectangle(block1Color, null, new Rect(halfX - halfBlockSize - blockSize - moveDistance, halfY - halfBlockSize, blockSize, blockSize));
                    drawingContext.DrawRectangle(block2Color, null, new Rect(halfX - halfBlockSize, halfY - halfBlockSize - blockSize - moveDistance, blockSize, blockSize));
                    drawingContext.DrawRectangle(block3Color, null, new Rect(halfX + halfBlockSize + moveDistance, halfY - halfBlockSize, blockSize, blockSize));
                    drawingContext.DrawRectangle(block4Color, null, new Rect(halfX - halfBlockSize, halfY + halfBlockSize + moveDistance, blockSize, blockSize));
                    break;
            }
        }
    }
}
